Terminals unused in grammar

   TRUE
   FALSE
   BOOL
   NEWLINE
   WHITESPACE


Grammar

    0 $accept: start $end

    1 $@1: %empty

    2 $@2: %empty

    3 start: $@1 libraries $@2 declarations body_main

    4 libraries: libraries LIBRARY
    5          | %empty

    6 $@3: %empty

    7 $@4: %empty

    8 body_main: INT MAIN LB RB LP $@3 body $@4 RP

    9 declarations: declarations dclr
   10             | %empty

   11 dclr: var_dclr
   12     | func_def

   13 $@5: %empty

   14 $@6: %empty

   15 $@7: %empty

   16 func_def: type ID LB $@5 decl_plist RB LP $@6 body $@7 RP

   17 $@8: %empty

   18 $@9: %empty

   19 $@10: %empty

   20 func_def: VOID ID LB $@8 decl_plist RB LP $@9 body $@10 RP

   21 decl_plist: decl_pl
   22           | %empty

   23 decl_pl: decl_pl COMMA decl_param
   24        | decl_param

   25 decl_param: type ID

   26 var_dclr: type varl SEMICOL

   27 type: INT
   28     | FLOAT

   29 varl: ID
   30     | ID EQUALS arith_expr
   31     | varl COMMA ID EQUALS arith_expr
   32     | varl COMMA ID
   33     | ID dims
   34     | varl COMMA ID dims

   35 dims: LS INT_VALUE RS
   36     | dims LS INT_VALUE RS

   37 dims2: LS arith_expr RS
   38      | dims2 LS arith_expr RS

   39 body: stmt_list

   40 stmt_list: stmt_list stmt
   41          | %empty

   42 $@11: %empty

   43 $@12: %empty

   44 stmt: LP $@11 stmt_list $@12 RP
   45     | var_dclr
   46     | expr SEMICOL
   47     | CONTINUE SEMICOL
   48     | BREAK SEMICOL
   49     | return_stmt SEMICOL

   50 $@13: %empty

   51 $@14: %empty

   52 stmt: IF LB expr RB LP $@13 stmt_list RP $@14 else_stmt

   53 $@15: %empty

   54 $@16: %empty

   55 $@17: %empty

   56 stmt: WHILE LB $@15 expr RB $@16 LP $@17 stmt_list RP

   57 $@18: %empty

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB LP $@18 stmt_list RP

   59 $@19: %empty

   60 $@20: %empty

   61 stmt: SWITCH LB ID $@19 RB LP $@20 case_stmt default RP

   62 $@21: %empty

   63 $@22: %empty

   64 stmt: SWITCH LB ID dims2 $@21 RB LP $@22 case_stmt default RP

   65 $@23: %empty

   66 else_stmt: ELSE LP $@23 stmt_list RP
   67          | %empty

   68 case_stmt: case_stmt CASE INT_VALUE COLON stmt_list
   69          | %empty

   70 default: DEFAULT COLON stmt_list
   71        | %empty

   72 return_stmt: RETURN
   73            | RETURN expr

   74 expr: arith_expr
   75     | log_expr
   76     | ID EQUALS arith_expr
   77     | ID dims2 EQUALS arith_expr

   78 log_expr: log_expr OR rel_expr
   79         | log_expr AND rel_expr
   80         | rel_expr

   81 rel_expr: arith_expr op3 arith_expr

   82 arith_expr: arith_expr op1 expr1
   83           | expr1

   84 expr1: expr1 op2 term
   85      | term

   86 term: LB arith_expr RB
   87     | func_call
   88     | const
   89     | ID
   90     | ID dims2

   91 const: INT_VALUE
   92      | FLOAT_VAL

   93 op1: ADD
   94    | SUB

   95 op2: MUL
   96    | DIV
   97    | MOD

   98 op3: GT
   99    | LT
  100    | GE
  101    | LE
  102    | COMP
  103    | NEQ

  104 func_call: ID LB paramlist RB

  105 paramlist: plist
  106          | %empty

  107 plist: plist COMMA expr
  108      | expr


Terminals, with rules where they appear

$end (0) 0
error (256)
OR (258) 78
AND (259) 79
DEFAULT (260) 70
CASE (261) 68
COLON (262) 68 70
SWITCH (263) 61 64
SEMICOL (264) 26 46 47 48 49 58
EQUALS (265) 30 31 76 77
ADD (266) 93
SUB (267) 94
MUL (268) 95
DIV (269) 96
MOD (270) 97
GT (271) 98
LT (272) 99
GE (273) 100
LE (274) 101
COMP (275) 102
NEQ (276) 103
MAIN (277) 8
IF (278) 52
FOR (279) 58
WHILE (280) 56
ELSE (281) 66
INT (282) 8 27
FLOAT (283) 28
TRUE (284)
FALSE (285)
BOOL (286)
LP (287) 8 16 20 44 52 56 58 61 64 66
RP (288) 8 16 20 44 52 56 58 61 64 66
LS (289) 35 36 37 38
RS (290) 35 36 37 38
LB (291) 8 16 20 52 56 58 61 64 86 104
RB (292) 8 16 20 52 56 58 61 64 86 104
RETURN (293) 72 73
BREAK (294) 48
CONTINUE (295) 47
COMMA (296) 23 31 32 34 107
INT_VALUE (297) 35 36 68 91
FLOAT_VAL (298) 92
LIBRARY (299) 4
ID (300) 16 20 25 29 30 31 32 33 34 61 64 76 77 89 90 104
NEWLINE (301)
WHITESPACE (302)
VOID (303) 20


Nonterminals, with rules where they appear

$accept (49)
    on left: 0
start (50)
    on left: 3, on right: 0
$@1 (51)
    on left: 1, on right: 3
$@2 (52)
    on left: 2, on right: 3
libraries (53)
    on left: 4 5, on right: 3 4
body_main (54)
    on left: 8, on right: 3
$@3 (55)
    on left: 6, on right: 8
$@4 (56)
    on left: 7, on right: 8
declarations (57)
    on left: 9 10, on right: 3 9
dclr (58)
    on left: 11 12, on right: 9
func_def (59)
    on left: 16 20, on right: 12
$@5 (60)
    on left: 13, on right: 16
$@6 (61)
    on left: 14, on right: 16
$@7 (62)
    on left: 15, on right: 16
$@8 (63)
    on left: 17, on right: 20
$@9 (64)
    on left: 18, on right: 20
$@10 (65)
    on left: 19, on right: 20
decl_plist (66)
    on left: 21 22, on right: 16 20
decl_pl (67)
    on left: 23 24, on right: 21 23
decl_param (68)
    on left: 25, on right: 23 24
var_dclr (69)
    on left: 26, on right: 11 45
type (70)
    on left: 27 28, on right: 16 25 26
varl (71)
    on left: 29 30 31 32 33 34, on right: 26 31 32 34
dims (72)
    on left: 35 36, on right: 33 34 36
dims2 (73)
    on left: 37 38, on right: 38 64 77 90
body (74)
    on left: 39, on right: 8 16 20
stmt_list (75)
    on left: 40 41, on right: 39 40 44 52 56 58 66 68 70
stmt (76)
    on left: 44 45 46 47 48 49 52 56 58 61 64, on right: 40
$@11 (77)
    on left: 42, on right: 44
$@12 (78)
    on left: 43, on right: 44
$@13 (79)
    on left: 50, on right: 52
$@14 (80)
    on left: 51, on right: 52
$@15 (81)
    on left: 53, on right: 56
$@16 (82)
    on left: 54, on right: 56
$@17 (83)
    on left: 55, on right: 56
$@18 (84)
    on left: 57, on right: 58
$@19 (85)
    on left: 59, on right: 61
$@20 (86)
    on left: 60, on right: 61
$@21 (87)
    on left: 62, on right: 64
$@22 (88)
    on left: 63, on right: 64
else_stmt (89)
    on left: 66 67, on right: 52
$@23 (90)
    on left: 65, on right: 66
case_stmt (91)
    on left: 68 69, on right: 61 64 68
default (92)
    on left: 70 71, on right: 61 64
return_stmt (93)
    on left: 72 73, on right: 49
expr (94)
    on left: 74 75 76 77, on right: 46 52 56 58 73 107 108
log_expr (95)
    on left: 78 79 80, on right: 75 78 79
rel_expr (96)
    on left: 81, on right: 78 79 80
arith_expr (97)
    on left: 82 83, on right: 30 31 37 38 74 76 77 81 82 86
expr1 (98)
    on left: 84 85, on right: 82 83 84
term (99)
    on left: 86 87 88 89 90, on right: 84 85
const (100)
    on left: 91 92, on right: 88
op1 (101)
    on left: 93 94, on right: 82
op2 (102)
    on left: 95 96 97, on right: 84
op3 (103)
    on left: 98 99 100 101 102 103, on right: 81
func_call (104)
    on left: 104, on right: 87
paramlist (105)
    on left: 105 106, on right: 104
plist (106)
    on left: 107 108, on right: 105 107


State 0

    0 $accept: . start $end

    $default  reduce using rule 1 ($@1)

    start  go to state 1
    $@1    go to state 2


State 1

    0 $accept: start . $end

    $end  shift, and go to state 3


State 2

    3 start: $@1 . libraries $@2 declarations body_main

    $default  reduce using rule 5 (libraries)

    libraries  go to state 4


State 3

    0 $accept: start $end .

    $default  accept


State 4

    3 start: $@1 libraries . $@2 declarations body_main
    4 libraries: libraries . LIBRARY

    LIBRARY  shift, and go to state 5

    $default  reduce using rule 2 ($@2)

    $@2  go to state 6


State 5

    4 libraries: libraries LIBRARY .

    $default  reduce using rule 4 (libraries)


State 6

    3 start: $@1 libraries $@2 . declarations body_main

    $default  reduce using rule 10 (declarations)

    declarations  go to state 7


State 7

    3 start: $@1 libraries $@2 declarations . body_main
    9 declarations: declarations . dclr

    INT    shift, and go to state 8
    FLOAT  shift, and go to state 9
    VOID   shift, and go to state 10

    body_main  go to state 11
    dclr       go to state 12
    func_def   go to state 13
    var_dclr   go to state 14
    type       go to state 15


State 8

    8 body_main: INT . MAIN LB RB LP $@3 body $@4 RP
   27 type: INT .

    MAIN  shift, and go to state 16

    $default  reduce using rule 27 (type)


State 9

   28 type: FLOAT .

    $default  reduce using rule 28 (type)


State 10

   20 func_def: VOID . ID LB $@8 decl_plist RB LP $@9 body $@10 RP

    ID  shift, and go to state 17


State 11

    3 start: $@1 libraries $@2 declarations body_main .

    $default  reduce using rule 3 (start)


State 12

    9 declarations: declarations dclr .

    $default  reduce using rule 9 (declarations)


State 13

   12 dclr: func_def .

    $default  reduce using rule 12 (dclr)


State 14

   11 dclr: var_dclr .

    $default  reduce using rule 11 (dclr)


State 15

   16 func_def: type . ID LB $@5 decl_plist RB LP $@6 body $@7 RP
   26 var_dclr: type . varl SEMICOL

    ID  shift, and go to state 18

    varl  go to state 19


State 16

    8 body_main: INT MAIN . LB RB LP $@3 body $@4 RP

    LB  shift, and go to state 20


State 17

   20 func_def: VOID ID . LB $@8 decl_plist RB LP $@9 body $@10 RP

    LB  shift, and go to state 21


State 18

   16 func_def: type ID . LB $@5 decl_plist RB LP $@6 body $@7 RP
   29 varl: ID .
   30     | ID . EQUALS arith_expr
   33     | ID . dims

    EQUALS  shift, and go to state 22
    LS      shift, and go to state 23
    LB      shift, and go to state 24

    $default  reduce using rule 29 (varl)

    dims  go to state 25


State 19

   26 var_dclr: type varl . SEMICOL
   31 varl: varl . COMMA ID EQUALS arith_expr
   32     | varl . COMMA ID
   34     | varl . COMMA ID dims

    SEMICOL  shift, and go to state 26
    COMMA    shift, and go to state 27


State 20

    8 body_main: INT MAIN LB . RB LP $@3 body $@4 RP

    RB  shift, and go to state 28


State 21

   20 func_def: VOID ID LB . $@8 decl_plist RB LP $@9 body $@10 RP

    $default  reduce using rule 17 ($@8)

    $@8  go to state 29


State 22

   30 varl: ID EQUALS . arith_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 34
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 23

   35 dims: LS . INT_VALUE RS

    INT_VALUE  shift, and go to state 39


State 24

   16 func_def: type ID LB . $@5 decl_plist RB LP $@6 body $@7 RP

    $default  reduce using rule 13 ($@5)

    $@5  go to state 40


State 25

   33 varl: ID dims .
   36 dims: dims . LS INT_VALUE RS

    LS  shift, and go to state 41

    $default  reduce using rule 33 (varl)


State 26

   26 var_dclr: type varl SEMICOL .

    $default  reduce using rule 26 (var_dclr)


State 27

   31 varl: varl COMMA . ID EQUALS arith_expr
   32     | varl COMMA . ID
   34     | varl COMMA . ID dims

    ID  shift, and go to state 42


State 28

    8 body_main: INT MAIN LB RB . LP $@3 body $@4 RP

    LP  shift, and go to state 43


State 29

   20 func_def: VOID ID LB $@8 . decl_plist RB LP $@9 body $@10 RP

    INT    shift, and go to state 44
    FLOAT  shift, and go to state 9

    $default  reduce using rule 22 (decl_plist)

    decl_plist  go to state 45
    decl_pl     go to state 46
    decl_param  go to state 47
    type        go to state 48


State 30

   86 term: LB . arith_expr RB

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 49
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 31

   91 const: INT_VALUE .

    $default  reduce using rule 91 (const)


State 32

   92 const: FLOAT_VAL .

    $default  reduce using rule 92 (const)


State 33

   89 term: ID .
   90     | ID . dims2
  104 func_call: ID . LB paramlist RB

    LS  shift, and go to state 50
    LB  shift, and go to state 51

    $default  reduce using rule 89 (term)

    dims2  go to state 52


State 34

   30 varl: ID EQUALS arith_expr .
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54

    $default  reduce using rule 30 (varl)

    op1  go to state 55


State 35

   83 arith_expr: expr1 .
   84 expr1: expr1 . op2 term

    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    MOD  shift, and go to state 58

    $default  reduce using rule 83 (arith_expr)

    op2  go to state 59


State 36

   85 expr1: term .

    $default  reduce using rule 85 (expr1)


State 37

   88 term: const .

    $default  reduce using rule 88 (term)


State 38

   87 term: func_call .

    $default  reduce using rule 87 (term)


State 39

   35 dims: LS INT_VALUE . RS

    RS  shift, and go to state 60


State 40

   16 func_def: type ID LB $@5 . decl_plist RB LP $@6 body $@7 RP

    INT    shift, and go to state 44
    FLOAT  shift, and go to state 9

    $default  reduce using rule 22 (decl_plist)

    decl_plist  go to state 61
    decl_pl     go to state 46
    decl_param  go to state 47
    type        go to state 48


State 41

   36 dims: dims LS . INT_VALUE RS

    INT_VALUE  shift, and go to state 62


State 42

   31 varl: varl COMMA ID . EQUALS arith_expr
   32     | varl COMMA ID .
   34     | varl COMMA ID . dims

    EQUALS  shift, and go to state 63
    LS      shift, and go to state 23

    $default  reduce using rule 32 (varl)

    dims  go to state 64


State 43

    8 body_main: INT MAIN LB RB LP . $@3 body $@4 RP

    $default  reduce using rule 6 ($@3)

    $@3  go to state 65


State 44

   27 type: INT .

    $default  reduce using rule 27 (type)


State 45

   20 func_def: VOID ID LB $@8 decl_plist . RB LP $@9 body $@10 RP

    RB  shift, and go to state 66


State 46

   21 decl_plist: decl_pl .
   23 decl_pl: decl_pl . COMMA decl_param

    COMMA  shift, and go to state 67

    $default  reduce using rule 21 (decl_plist)


State 47

   24 decl_pl: decl_param .

    $default  reduce using rule 24 (decl_pl)


State 48

   25 decl_param: type . ID

    ID  shift, and go to state 68


State 49

   82 arith_expr: arith_expr . op1 expr1
   86 term: LB arith_expr . RB

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54
    RB   shift, and go to state 69

    op1  go to state 55


State 50

   37 dims2: LS . arith_expr RS

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 70
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 51

  104 func_call: ID LB . paramlist RB

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 106 (paramlist)

    expr        go to state 72
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38
    paramlist   go to state 76
    plist       go to state 77


State 52

   38 dims2: dims2 . LS arith_expr RS
   90 term: ID dims2 .

    LS  shift, and go to state 78

    $default  reduce using rule 90 (term)


State 53

   93 op1: ADD .

    $default  reduce using rule 93 (op1)


State 54

   94 op1: SUB .

    $default  reduce using rule 94 (op1)


State 55

   82 arith_expr: arith_expr op1 . expr1

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    expr1      go to state 79
    term       go to state 36
    const      go to state 37
    func_call  go to state 38


State 56

   95 op2: MUL .

    $default  reduce using rule 95 (op2)


State 57

   96 op2: DIV .

    $default  reduce using rule 96 (op2)


State 58

   97 op2: MOD .

    $default  reduce using rule 97 (op2)


State 59

   84 expr1: expr1 op2 . term

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    term       go to state 80
    const      go to state 37
    func_call  go to state 38


State 60

   35 dims: LS INT_VALUE RS .

    $default  reduce using rule 35 (dims)


State 61

   16 func_def: type ID LB $@5 decl_plist . RB LP $@6 body $@7 RP

    RB  shift, and go to state 81


State 62

   36 dims: dims LS INT_VALUE . RS

    RS  shift, and go to state 82


State 63

   31 varl: varl COMMA ID EQUALS . arith_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 83
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 64

   34 varl: varl COMMA ID dims .
   36 dims: dims . LS INT_VALUE RS

    LS  shift, and go to state 41

    $default  reduce using rule 34 (varl)


State 65

    8 body_main: INT MAIN LB RB LP $@3 . body $@4 RP

    $default  reduce using rule 41 (stmt_list)

    body       go to state 84
    stmt_list  go to state 85


State 66

   20 func_def: VOID ID LB $@8 decl_plist RB . LP $@9 body $@10 RP

    LP  shift, and go to state 86


State 67

   23 decl_pl: decl_pl COMMA . decl_param

    INT    shift, and go to state 44
    FLOAT  shift, and go to state 9

    decl_param  go to state 87
    type        go to state 48


State 68

   25 decl_param: type ID .

    $default  reduce using rule 25 (decl_param)


State 69

   86 term: LB arith_expr RB .

    $default  reduce using rule 86 (term)


State 70

   37 dims2: LS arith_expr . RS
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54
    RS   shift, and go to state 88

    op1  go to state 55


State 71

   76 expr: ID . EQUALS arith_expr
   77     | ID . dims2 EQUALS arith_expr
   89 term: ID .
   90     | ID . dims2
  104 func_call: ID . LB paramlist RB

    EQUALS  shift, and go to state 89
    LS      shift, and go to state 50
    LB      shift, and go to state 51

    $default  reduce using rule 89 (term)

    dims2  go to state 90


State 72

  108 plist: expr .

    $default  reduce using rule 108 (plist)


State 73

   75 expr: log_expr .
   78 log_expr: log_expr . OR rel_expr
   79         | log_expr . AND rel_expr

    OR   shift, and go to state 91
    AND  shift, and go to state 92

    $default  reduce using rule 75 (expr)


State 74

   80 log_expr: rel_expr .

    $default  reduce using rule 80 (log_expr)


State 75

   74 expr: arith_expr .
   81 rel_expr: arith_expr . op3 arith_expr
   82 arith_expr: arith_expr . op1 expr1

    ADD   shift, and go to state 53
    SUB   shift, and go to state 54
    GT    shift, and go to state 93
    LT    shift, and go to state 94
    GE    shift, and go to state 95
    LE    shift, and go to state 96
    COMP  shift, and go to state 97
    NEQ   shift, and go to state 98

    $default  reduce using rule 74 (expr)

    op1  go to state 55
    op3  go to state 99


State 76

  104 func_call: ID LB paramlist . RB

    RB  shift, and go to state 100


State 77

  105 paramlist: plist .
  107 plist: plist . COMMA expr

    COMMA  shift, and go to state 101

    $default  reduce using rule 105 (paramlist)


State 78

   38 dims2: dims2 LS . arith_expr RS

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 102
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 79

   82 arith_expr: arith_expr op1 expr1 .
   84 expr1: expr1 . op2 term

    MUL  shift, and go to state 56
    DIV  shift, and go to state 57
    MOD  shift, and go to state 58

    $default  reduce using rule 82 (arith_expr)

    op2  go to state 59


State 80

   84 expr1: expr1 op2 term .

    $default  reduce using rule 84 (expr1)


State 81

   16 func_def: type ID LB $@5 decl_plist RB . LP $@6 body $@7 RP

    LP  shift, and go to state 103


State 82

   36 dims: dims LS INT_VALUE RS .

    $default  reduce using rule 36 (dims)


State 83

   31 varl: varl COMMA ID EQUALS arith_expr .
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54

    $default  reduce using rule 31 (varl)

    op1  go to state 55


State 84

    8 body_main: INT MAIN LB RB LP $@3 body . $@4 RP

    $default  reduce using rule 7 ($@4)

    $@4  go to state 104


State 85

   39 body: stmt_list .
   40 stmt_list: stmt_list . stmt

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 39 (body)

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 86

   20 func_def: VOID ID LB $@8 decl_plist RB LP . $@9 body $@10 RP

    $default  reduce using rule 18 ($@9)

    $@9  go to state 118


State 87

   23 decl_pl: decl_pl COMMA decl_param .

    $default  reduce using rule 23 (decl_pl)


State 88

   37 dims2: LS arith_expr RS .

    $default  reduce using rule 37 (dims2)


State 89

   76 expr: ID EQUALS . arith_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 119
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 90

   38 dims2: dims2 . LS arith_expr RS
   77 expr: ID dims2 . EQUALS arith_expr
   90 term: ID dims2 .

    EQUALS  shift, and go to state 120
    LS      shift, and go to state 78

    $default  reduce using rule 90 (term)


State 91

   78 log_expr: log_expr OR . rel_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    rel_expr    go to state 121
    arith_expr  go to state 122
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 92

   79 log_expr: log_expr AND . rel_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    rel_expr    go to state 123
    arith_expr  go to state 122
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 93

   98 op3: GT .

    $default  reduce using rule 98 (op3)


State 94

   99 op3: LT .

    $default  reduce using rule 99 (op3)


State 95

  100 op3: GE .

    $default  reduce using rule 100 (op3)


State 96

  101 op3: LE .

    $default  reduce using rule 101 (op3)


State 97

  102 op3: COMP .

    $default  reduce using rule 102 (op3)


State 98

  103 op3: NEQ .

    $default  reduce using rule 103 (op3)


State 99

   81 rel_expr: arith_expr op3 . arith_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 124
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 100

  104 func_call: ID LB paramlist RB .

    $default  reduce using rule 104 (func_call)


State 101

  107 plist: plist COMMA . expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 125
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 102

   38 dims2: dims2 LS arith_expr . RS
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54
    RS   shift, and go to state 126

    op1  go to state 55


State 103

   16 func_def: type ID LB $@5 decl_plist RB LP . $@6 body $@7 RP

    $default  reduce using rule 14 ($@6)

    $@6  go to state 127


State 104

    8 body_main: INT MAIN LB RB LP $@3 body $@4 . RP

    RP  shift, and go to state 128


State 105

   61 stmt: SWITCH . LB ID $@19 RB LP $@20 case_stmt default RP
   64     | SWITCH . LB ID dims2 $@21 RB LP $@22 case_stmt default RP

    LB  shift, and go to state 129


State 106

   52 stmt: IF . LB expr RB LP $@13 stmt_list RP $@14 else_stmt

    LB  shift, and go to state 130


State 107

   58 stmt: FOR . LB expr SEMICOL expr SEMICOL expr RB LP $@18 stmt_list RP

    LB  shift, and go to state 131


State 108

   56 stmt: WHILE . LB $@15 expr RB $@16 LP $@17 stmt_list RP

    LB  shift, and go to state 132


State 109

   44 stmt: LP . $@11 stmt_list $@12 RP

    $default  reduce using rule 42 ($@11)

    $@11  go to state 133


State 110

   72 return_stmt: RETURN .
   73            | RETURN . expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 72 (return_stmt)

    expr        go to state 134
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 111

   48 stmt: BREAK . SEMICOL

    SEMICOL  shift, and go to state 135


State 112

   47 stmt: CONTINUE . SEMICOL

    SEMICOL  shift, and go to state 136


State 113

   45 stmt: var_dclr .

    $default  reduce using rule 45 (stmt)


State 114

   26 var_dclr: type . varl SEMICOL

    ID  shift, and go to state 137

    varl  go to state 19


State 115

   40 stmt_list: stmt_list stmt .

    $default  reduce using rule 40 (stmt_list)


State 116

   49 stmt: return_stmt . SEMICOL

    SEMICOL  shift, and go to state 138


State 117

   46 stmt: expr . SEMICOL

    SEMICOL  shift, and go to state 139


State 118

   20 func_def: VOID ID LB $@8 decl_plist RB LP $@9 . body $@10 RP

    $default  reduce using rule 41 (stmt_list)

    body       go to state 140
    stmt_list  go to state 85


State 119

   76 expr: ID EQUALS arith_expr .
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54

    $default  reduce using rule 76 (expr)

    op1  go to state 55


State 120

   77 expr: ID dims2 EQUALS . arith_expr

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 33

    arith_expr  go to state 141
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 121

   78 log_expr: log_expr OR rel_expr .

    $default  reduce using rule 78 (log_expr)


State 122

   81 rel_expr: arith_expr . op3 arith_expr
   82 arith_expr: arith_expr . op1 expr1

    ADD   shift, and go to state 53
    SUB   shift, and go to state 54
    GT    shift, and go to state 93
    LT    shift, and go to state 94
    GE    shift, and go to state 95
    LE    shift, and go to state 96
    COMP  shift, and go to state 97
    NEQ   shift, and go to state 98

    op1  go to state 55
    op3  go to state 99


State 123

   79 log_expr: log_expr AND rel_expr .

    $default  reduce using rule 79 (log_expr)


State 124

   81 rel_expr: arith_expr op3 arith_expr .
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54

    $default  reduce using rule 81 (rel_expr)

    op1  go to state 55


State 125

  107 plist: plist COMMA expr .

    $default  reduce using rule 107 (plist)


State 126

   38 dims2: dims2 LS arith_expr RS .

    $default  reduce using rule 38 (dims2)


State 127

   16 func_def: type ID LB $@5 decl_plist RB LP $@6 . body $@7 RP

    $default  reduce using rule 41 (stmt_list)

    body       go to state 142
    stmt_list  go to state 85


State 128

    8 body_main: INT MAIN LB RB LP $@3 body $@4 RP .

    $default  reduce using rule 8 (body_main)


State 129

   61 stmt: SWITCH LB . ID $@19 RB LP $@20 case_stmt default RP
   64     | SWITCH LB . ID dims2 $@21 RB LP $@22 case_stmt default RP

    ID  shift, and go to state 143


State 130

   52 stmt: IF LB . expr RB LP $@13 stmt_list RP $@14 else_stmt

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 144
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 131

   58 stmt: FOR LB . expr SEMICOL expr SEMICOL expr RB LP $@18 stmt_list RP

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 145
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 132

   56 stmt: WHILE LB . $@15 expr RB $@16 LP $@17 stmt_list RP

    $default  reduce using rule 53 ($@15)

    $@15  go to state 146


State 133

   44 stmt: LP $@11 . stmt_list $@12 RP

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 147


State 134

   73 return_stmt: RETURN expr .

    $default  reduce using rule 73 (return_stmt)


State 135

   48 stmt: BREAK SEMICOL .

    $default  reduce using rule 48 (stmt)


State 136

   47 stmt: CONTINUE SEMICOL .

    $default  reduce using rule 47 (stmt)


State 137

   29 varl: ID .
   30     | ID . EQUALS arith_expr
   33     | ID . dims

    EQUALS  shift, and go to state 22
    LS      shift, and go to state 23

    $default  reduce using rule 29 (varl)

    dims  go to state 25


State 138

   49 stmt: return_stmt SEMICOL .

    $default  reduce using rule 49 (stmt)


State 139

   46 stmt: expr SEMICOL .

    $default  reduce using rule 46 (stmt)


State 140

   20 func_def: VOID ID LB $@8 decl_plist RB LP $@9 body . $@10 RP

    $default  reduce using rule 19 ($@10)

    $@10  go to state 148


State 141

   77 expr: ID dims2 EQUALS arith_expr .
   82 arith_expr: arith_expr . op1 expr1

    ADD  shift, and go to state 53
    SUB  shift, and go to state 54

    $default  reduce using rule 77 (expr)

    op1  go to state 55


State 142

   16 func_def: type ID LB $@5 decl_plist RB LP $@6 body . $@7 RP

    $default  reduce using rule 15 ($@7)

    $@7  go to state 149


State 143

   61 stmt: SWITCH LB ID . $@19 RB LP $@20 case_stmt default RP
   64     | SWITCH LB ID . dims2 $@21 RB LP $@22 case_stmt default RP

    LS  shift, and go to state 50

    $default  reduce using rule 59 ($@19)

    dims2  go to state 150
    $@19   go to state 151


State 144

   52 stmt: IF LB expr . RB LP $@13 stmt_list RP $@14 else_stmt

    RB  shift, and go to state 152


State 145

   58 stmt: FOR LB expr . SEMICOL expr SEMICOL expr RB LP $@18 stmt_list RP

    SEMICOL  shift, and go to state 153


State 146

   56 stmt: WHILE LB $@15 . expr RB $@16 LP $@17 stmt_list RP

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 154
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 147

   40 stmt_list: stmt_list . stmt
   44 stmt: LP $@11 stmt_list . $@12 RP

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 43 ($@12)

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    $@12         go to state 155
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 148

   20 func_def: VOID ID LB $@8 decl_plist RB LP $@9 body $@10 . RP

    RP  shift, and go to state 156


State 149

   16 func_def: type ID LB $@5 decl_plist RB LP $@6 body $@7 . RP

    RP  shift, and go to state 157


State 150

   38 dims2: dims2 . LS arith_expr RS
   64 stmt: SWITCH LB ID dims2 . $@21 RB LP $@22 case_stmt default RP

    LS  shift, and go to state 78

    $default  reduce using rule 62 ($@21)

    $@21  go to state 158


State 151

   61 stmt: SWITCH LB ID $@19 . RB LP $@20 case_stmt default RP

    RB  shift, and go to state 159


State 152

   52 stmt: IF LB expr RB . LP $@13 stmt_list RP $@14 else_stmt

    LP  shift, and go to state 160


State 153

   58 stmt: FOR LB expr SEMICOL . expr SEMICOL expr RB LP $@18 stmt_list RP

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 161
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 154

   56 stmt: WHILE LB $@15 expr . RB $@16 LP $@17 stmt_list RP

    RB  shift, and go to state 162


State 155

   44 stmt: LP $@11 stmt_list $@12 . RP

    RP  shift, and go to state 163


State 156

   20 func_def: VOID ID LB $@8 decl_plist RB LP $@9 body $@10 RP .

    $default  reduce using rule 20 (func_def)


State 157

   16 func_def: type ID LB $@5 decl_plist RB LP $@6 body $@7 RP .

    $default  reduce using rule 16 (func_def)


State 158

   64 stmt: SWITCH LB ID dims2 $@21 . RB LP $@22 case_stmt default RP

    RB  shift, and go to state 164


State 159

   61 stmt: SWITCH LB ID $@19 RB . LP $@20 case_stmt default RP

    LP  shift, and go to state 165


State 160

   52 stmt: IF LB expr RB LP . $@13 stmt_list RP $@14 else_stmt

    $default  reduce using rule 50 ($@13)

    $@13  go to state 166


State 161

   58 stmt: FOR LB expr SEMICOL expr . SEMICOL expr RB LP $@18 stmt_list RP

    SEMICOL  shift, and go to state 167


State 162

   56 stmt: WHILE LB $@15 expr RB . $@16 LP $@17 stmt_list RP

    $default  reduce using rule 54 ($@16)

    $@16  go to state 168


State 163

   44 stmt: LP $@11 stmt_list $@12 RP .

    $default  reduce using rule 44 (stmt)


State 164

   64 stmt: SWITCH LB ID dims2 $@21 RB . LP $@22 case_stmt default RP

    LP  shift, and go to state 169


State 165

   61 stmt: SWITCH LB ID $@19 RB LP . $@20 case_stmt default RP

    $default  reduce using rule 60 ($@20)

    $@20  go to state 170


State 166

   52 stmt: IF LB expr RB LP $@13 . stmt_list RP $@14 else_stmt

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 171


State 167

   58 stmt: FOR LB expr SEMICOL expr SEMICOL . expr RB LP $@18 stmt_list RP

    LB         shift, and go to state 30
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    expr        go to state 172
    log_expr    go to state 73
    rel_expr    go to state 74
    arith_expr  go to state 75
    expr1       go to state 35
    term        go to state 36
    const       go to state 37
    func_call   go to state 38


State 168

   56 stmt: WHILE LB $@15 expr RB $@16 . LP $@17 stmt_list RP

    LP  shift, and go to state 173


State 169

   64 stmt: SWITCH LB ID dims2 $@21 RB LP . $@22 case_stmt default RP

    $default  reduce using rule 63 ($@22)

    $@22  go to state 174


State 170

   61 stmt: SWITCH LB ID $@19 RB LP $@20 . case_stmt default RP

    $default  reduce using rule 69 (case_stmt)

    case_stmt  go to state 175


State 171

   40 stmt_list: stmt_list . stmt
   52 stmt: IF LB expr RB LP $@13 stmt_list . RP $@14 else_stmt

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    RP         shift, and go to state 176
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 172

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr . RB LP $@18 stmt_list RP

    RB  shift, and go to state 177


State 173

   56 stmt: WHILE LB $@15 expr RB $@16 LP . $@17 stmt_list RP

    $default  reduce using rule 55 ($@17)

    $@17  go to state 178


State 174

   64 stmt: SWITCH LB ID dims2 $@21 RB LP $@22 . case_stmt default RP

    $default  reduce using rule 69 (case_stmt)

    case_stmt  go to state 179


State 175

   61 stmt: SWITCH LB ID $@19 RB LP $@20 case_stmt . default RP
   68 case_stmt: case_stmt . CASE INT_VALUE COLON stmt_list

    DEFAULT  shift, and go to state 180
    CASE     shift, and go to state 181

    $default  reduce using rule 71 (default)

    default  go to state 182


State 176

   52 stmt: IF LB expr RB LP $@13 stmt_list RP . $@14 else_stmt

    $default  reduce using rule 51 ($@14)

    $@14  go to state 183


State 177

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB . LP $@18 stmt_list RP

    LP  shift, and go to state 184


State 178

   56 stmt: WHILE LB $@15 expr RB $@16 LP $@17 . stmt_list RP

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 185


State 179

   64 stmt: SWITCH LB ID dims2 $@21 RB LP $@22 case_stmt . default RP
   68 case_stmt: case_stmt . CASE INT_VALUE COLON stmt_list

    DEFAULT  shift, and go to state 180
    CASE     shift, and go to state 181

    $default  reduce using rule 71 (default)

    default  go to state 186


State 180

   70 default: DEFAULT . COLON stmt_list

    COLON  shift, and go to state 187


State 181

   68 case_stmt: case_stmt CASE . INT_VALUE COLON stmt_list

    INT_VALUE  shift, and go to state 188


State 182

   61 stmt: SWITCH LB ID $@19 RB LP $@20 case_stmt default . RP

    RP  shift, and go to state 189


State 183

   52 stmt: IF LB expr RB LP $@13 stmt_list RP $@14 . else_stmt

    ELSE  shift, and go to state 190

    $default  reduce using rule 67 (else_stmt)

    else_stmt  go to state 191


State 184

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB LP . $@18 stmt_list RP

    $default  reduce using rule 57 ($@18)

    $@18  go to state 192


State 185

   40 stmt_list: stmt_list . stmt
   56 stmt: WHILE LB $@15 expr RB $@16 LP $@17 stmt_list . RP

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    RP         shift, and go to state 193
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 186

   64 stmt: SWITCH LB ID dims2 $@21 RB LP $@22 case_stmt default . RP

    RP  shift, and go to state 194


State 187

   70 default: DEFAULT COLON . stmt_list

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 195


State 188

   68 case_stmt: case_stmt CASE INT_VALUE . COLON stmt_list

    COLON  shift, and go to state 196


State 189

   61 stmt: SWITCH LB ID $@19 RB LP $@20 case_stmt default RP .

    $default  reduce using rule 61 (stmt)


State 190

   66 else_stmt: ELSE . LP $@23 stmt_list RP

    LP  shift, and go to state 197


State 191

   52 stmt: IF LB expr RB LP $@13 stmt_list RP $@14 else_stmt .

    $default  reduce using rule 52 (stmt)


State 192

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB LP $@18 . stmt_list RP

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 198


State 193

   56 stmt: WHILE LB $@15 expr RB $@16 LP $@17 stmt_list RP .

    $default  reduce using rule 56 (stmt)


State 194

   64 stmt: SWITCH LB ID dims2 $@21 RB LP $@22 case_stmt default RP .

    $default  reduce using rule 64 (stmt)


State 195

   40 stmt_list: stmt_list . stmt
   70 default: DEFAULT COLON stmt_list .

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 70 (default)

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 196

   68 case_stmt: case_stmt CASE INT_VALUE COLON . stmt_list

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 199


State 197

   66 else_stmt: ELSE LP . $@23 stmt_list RP

    $default  reduce using rule 65 ($@23)

    $@23  go to state 200


State 198

   40 stmt_list: stmt_list . stmt
   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB LP $@18 stmt_list . RP

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    RP         shift, and go to state 201
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 199

   40 stmt_list: stmt_list . stmt
   68 case_stmt: case_stmt CASE INT_VALUE COLON stmt_list .

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    $default  reduce using rule 68 (case_stmt)

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 200

   66 else_stmt: ELSE LP $@23 . stmt_list RP

    $default  reduce using rule 41 (stmt_list)

    stmt_list  go to state 202


State 201

   58 stmt: FOR LB expr SEMICOL expr SEMICOL expr RB LP $@18 stmt_list RP .

    $default  reduce using rule 58 (stmt)


State 202

   40 stmt_list: stmt_list . stmt
   66 else_stmt: ELSE LP $@23 stmt_list . RP

    SWITCH     shift, and go to state 105
    IF         shift, and go to state 106
    FOR        shift, and go to state 107
    WHILE      shift, and go to state 108
    INT        shift, and go to state 44
    FLOAT      shift, and go to state 9
    LP         shift, and go to state 109
    RP         shift, and go to state 203
    LB         shift, and go to state 30
    RETURN     shift, and go to state 110
    BREAK      shift, and go to state 111
    CONTINUE   shift, and go to state 112
    INT_VALUE  shift, and go to state 31
    FLOAT_VAL  shift, and go to state 32
    ID         shift, and go to state 71

    var_dclr     go to state 113
    type         go to state 114
    stmt         go to state 115
    return_stmt  go to state 116
    expr         go to state 117
    log_expr     go to state 73
    rel_expr     go to state 74
    arith_expr   go to state 75
    expr1        go to state 35
    term         go to state 36
    const        go to state 37
    func_call    go to state 38


State 203

   66 else_stmt: ELSE LP $@23 stmt_list RP .

    $default  reduce using rule 66 (else_stmt)
